"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
import pydantic
from pydantic import model_serializer
from rapidapi_realtor_search_client.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from typing import Any, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class PrimaryPhotoTypedDict(TypedDict):
    href: NotRequired[str]


class PrimaryPhoto(BaseModel):
    href: Optional[str] = None


class PhotosTypedDict(TypedDict):
    href: NotRequired[str]


class Photos(BaseModel):
    href: Optional[str] = None


class CountyTypedDict(TypedDict):
    name: NotRequired[str]


class County(BaseModel):
    name: Optional[str] = None


class NeighborhoodsTypedDict(TypedDict):
    name: NotRequired[str]
    city: NotRequired[str]
    state_code: NotRequired[str]
    level: NotRequired[str]


class Neighborhoods(BaseModel):
    name: Optional[str] = None

    city: Optional[str] = None

    state_code: Optional[str] = None

    level: Optional[str] = None


class CoordinateTypedDict(TypedDict):
    lat: NotRequired[float]
    lon: NotRequired[float]


class Coordinate(BaseModel):
    lat: Optional[float] = None

    lon: Optional[float] = None


class AddressTypedDict(TypedDict):
    line: NotRequired[str]
    unit: NotRequired[Nullable[Any]]
    street_number: NotRequired[str]
    street_name: NotRequired[str]
    street_suffix: NotRequired[str]
    city: NotRequired[str]
    postal_code: NotRequired[str]
    state_code: NotRequired[str]
    state: NotRequired[str]
    country: NotRequired[str]
    coordinate: NotRequired[CoordinateTypedDict]


class Address(BaseModel):
    line: Optional[str] = None

    unit: OptionalNullable[Any] = UNSET

    street_number: Optional[str] = None

    street_name: Optional[str] = None

    street_suffix: Optional[str] = None

    city: Optional[str] = None

    postal_code: Optional[str] = None

    state_code: Optional[str] = None

    state: Optional[str] = None

    country: Optional[str] = None

    coordinate: Optional[Coordinate] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "line",
            "unit",
            "street_number",
            "street_name",
            "street_suffix",
            "city",
            "postal_code",
            "state_code",
            "state",
            "country",
            "coordinate",
        ]
        nullable_fields = ["unit"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class LocationTypedDict(TypedDict):
    county: NotRequired[CountyTypedDict]
    neighborhoods: NotRequired[List[NeighborhoodsTypedDict]]
    address: NotRequired[AddressTypedDict]
    street_view_url: NotRequired[str]


class Location(BaseModel):
    county: Optional[County] = None

    neighborhoods: Optional[List[Neighborhoods]] = None

    address: Optional[Address] = None

    street_view_url: Optional[str] = None


class ProductsTypedDict(TypedDict):
    products: NotRequired[List[str]]


class Products(BaseModel):
    products: Optional[List[str]] = None


class DescriptionTypedDict(TypedDict):
    baths: NotRequired[Nullable[Any]]
    baths_min: NotRequired[int]
    baths_max: NotRequired[int]
    baths_full_calc: NotRequired[Nullable[Any]]
    baths_partial_calc: NotRequired[Nullable[Any]]
    beds_min: NotRequired[int]
    beds_max: NotRequired[int]
    beds: NotRequired[Nullable[Any]]
    sqft: NotRequired[Nullable[Any]]
    lot_sqft: NotRequired[Nullable[Any]]
    type: NotRequired[str]
    sqft_min: NotRequired[int]
    sqft_max: NotRequired[int]


class Description(BaseModel):
    baths: OptionalNullable[Any] = UNSET

    baths_min: Optional[int] = None

    baths_max: Optional[int] = None

    baths_full_calc: OptionalNullable[Any] = UNSET

    baths_partial_calc: OptionalNullable[Any] = UNSET

    beds_min: Optional[int] = None

    beds_max: Optional[int] = None

    beds: OptionalNullable[Any] = UNSET

    sqft: OptionalNullable[Any] = UNSET

    lot_sqft: OptionalNullable[Any] = UNSET

    type: Optional[str] = None

    sqft_min: Optional[int] = None

    sqft_max: Optional[int] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "baths",
            "baths_min",
            "baths_max",
            "baths_full_calc",
            "baths_partial_calc",
            "beds_min",
            "beds_max",
            "beds",
            "sqft",
            "lot_sqft",
            "type",
            "sqft_min",
            "sqft_max",
        ]
        nullable_fields = [
            "baths",
            "baths_full_calc",
            "baths_partial_calc",
            "beds",
            "sqft",
            "lot_sqft",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class BrandingTypedDict(TypedDict):
    type: NotRequired[str]
    name: NotRequired[Nullable[Any]]


class Branding(BaseModel):
    type: Optional[str] = None

    name: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["type", "name"]
        nullable_fields = ["name"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class FlagsTypedDict(TypedDict):
    is_contingent: NotRequired[Nullable[Any]]
    is_new_construction: NotRequired[Nullable[Any]]
    is_pending: NotRequired[Nullable[Any]]
    is_foreclosure: NotRequired[Nullable[Any]]
    is_deal_available: NotRequired[Nullable[Any]]
    is_plan: NotRequired[Nullable[Any]]
    is_price_reduced: NotRequired[Nullable[Any]]
    is_new_listing: NotRequired[bool]
    is_coming_soon: NotRequired[Nullable[Any]]


class Flags(BaseModel):
    is_contingent: OptionalNullable[Any] = UNSET

    is_new_construction: OptionalNullable[Any] = UNSET

    is_pending: OptionalNullable[Any] = UNSET

    is_foreclosure: OptionalNullable[Any] = UNSET

    is_deal_available: OptionalNullable[Any] = UNSET

    is_plan: OptionalNullable[Any] = UNSET

    is_price_reduced: OptionalNullable[Any] = UNSET

    is_new_listing: Optional[bool] = None

    is_coming_soon: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "is_contingent",
            "is_new_construction",
            "is_pending",
            "is_foreclosure",
            "is_deal_available",
            "is_plan",
            "is_price_reduced",
            "is_new_listing",
            "is_coming_soon",
        ]
        nullable_fields = [
            "is_contingent",
            "is_new_construction",
            "is_pending",
            "is_foreclosure",
            "is_deal_available",
            "is_plan",
            "is_price_reduced",
            "is_coming_soon",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class OpcityLeadAttributesTypedDict(TypedDict):
    flip_the_market_enabled: NotRequired[bool]


class OpcityLeadAttributes(BaseModel):
    flip_the_market_enabled: Optional[bool] = None


class LeadAttributesTypedDict(TypedDict):
    opcity_lead_attributes: NotRequired[OpcityLeadAttributesTypedDict]
    show_contact_an_agent: NotRequired[bool]
    is_tcpa_message_enabled: NotRequired[Nullable[Any]]
    is_premium_ldp: NotRequired[bool]


class LeadAttributes(BaseModel):
    opcity_lead_attributes: Optional[OpcityLeadAttributes] = None

    show_contact_an_agent: Optional[bool] = None

    is_tcpa_message_enabled: OptionalNullable[Any] = UNSET

    is_premium_ldp: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "opcity_lead_attributes",
            "show_contact_an_agent",
            "is_tcpa_message_enabled",
            "is_premium_ldp",
        ]
        nullable_fields = ["is_tcpa_message_enabled"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class OfficeTypedDict(TypedDict):
    name: NotRequired[str]


class Office(BaseModel):
    name: Optional[str] = None


class AdvertisersTypedDict(TypedDict):
    fulfillment_id: NotRequired[str]
    name: NotRequired[str]
    type: NotRequired[str]
    office: NotRequired[OfficeTypedDict]
    builder: NotRequired[Nullable[Any]]


class Advertisers(BaseModel):
    fulfillment_id: Optional[str] = None

    name: Optional[str] = None

    type: Optional[str] = None

    office: Optional[Office] = None

    builder: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["fulfillment_id", "name", "type", "office", "builder"]
        nullable_fields = ["builder"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class SourceTypedDict(TypedDict):
    type: NotRequired[str]
    plan_id: NotRequired[Nullable[Any]]
    listing_id: NotRequired[str]
    community_id: NotRequired[int]
    id: NotRequired[str]
    name: NotRequired[str]
    disclaimer: NotRequired[Nullable[Any]]
    feed_type: NotRequired[str]
    agents: NotRequired[Nullable[Any]]


class Source(BaseModel):
    type: Optional[str] = None

    plan_id: OptionalNullable[Any] = UNSET

    listing_id: Optional[str] = None

    community_id: Optional[int] = None

    id: Optional[str] = None

    name: Optional[str] = None

    disclaimer: OptionalNullable[Any] = UNSET

    feed_type: Optional[str] = None

    agents: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "type",
            "plan_id",
            "listing_id",
            "community_id",
            "id",
            "name",
            "disclaimer",
            "feed_type",
            "agents",
        ]
        nullable_fields = ["plan_id", "disclaimer", "agents"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PetPolicyTypedDict(TypedDict):
    cats: NotRequired[bool]
    dogs: NotRequired[bool]
    dogs_small: NotRequired[bool]
    dogs_large: NotRequired[bool]


class PetPolicy(BaseModel):
    cats: Optional[bool] = None

    dogs: Optional[bool] = None

    dogs_small: Optional[bool] = None

    dogs_large: Optional[bool] = None


class DetailsTypedDict(TypedDict):
    text: NotRequired[List[str]]
    category: NotRequired[str]


class Details(BaseModel):
    text: Optional[List[str]] = None

    category: Optional[str] = None


class PropertyTypedDict(TypedDict):
    typename: NotRequired[str]
    property_id: NotRequired[str]
    listing_id: NotRequired[str]
    status: NotRequired[str]
    primary_photo: NotRequired[PrimaryPhotoTypedDict]
    photo_count: NotRequired[int]
    photos: NotRequired[List[PhotosTypedDict]]
    location: NotRequired[LocationTypedDict]
    list_price: NotRequired[Nullable[Any]]
    list_date: NotRequired[str]
    list_price_min: NotRequired[int]
    list_price_max: NotRequired[int]
    price_reduced_date: NotRequired[Nullable[Any]]
    price_reduced_amount: NotRequired[Nullable[Any]]
    last_sold_date: NotRequired[Nullable[Any]]
    last_sold_price: NotRequired[Nullable[Any]]
    href: NotRequired[str]
    products: NotRequired[ProductsTypedDict]
    description: NotRequired[DescriptionTypedDict]
    open_houses: NotRequired[Nullable[Any]]
    branding: NotRequired[List[BrandingTypedDict]]
    flags: NotRequired[FlagsTypedDict]
    lead_attributes: NotRequired[LeadAttributesTypedDict]
    virtual_tours: NotRequired[Nullable[Any]]
    matterport: NotRequired[bool]
    advertisers: NotRequired[List[AdvertisersTypedDict]]
    source: NotRequired[SourceTypedDict]
    pet_policy: NotRequired[PetPolicyTypedDict]
    property_history: NotRequired[Nullable[Any]]
    search_promotions: NotRequired[Nullable[Any]]
    has_specials: NotRequired[bool]
    estimate: NotRequired[Nullable[Any]]
    current_estimates: NotRequired[List[Any]]
    details: NotRequired[List[DetailsTypedDict]]


class Property(BaseModel):
    typename: Annotated[Optional[str], pydantic.Field(alias="__typename")] = None

    property_id: Optional[str] = None

    listing_id: Optional[str] = None

    status: Optional[str] = None

    primary_photo: Optional[PrimaryPhoto] = None

    photo_count: Optional[int] = None

    photos: Optional[List[Photos]] = None

    location: Optional[Location] = None

    list_price: OptionalNullable[Any] = UNSET

    list_date: Optional[str] = None

    list_price_min: Optional[int] = None

    list_price_max: Optional[int] = None

    price_reduced_date: OptionalNullable[Any] = UNSET

    price_reduced_amount: OptionalNullable[Any] = UNSET

    last_sold_date: OptionalNullable[Any] = UNSET

    last_sold_price: OptionalNullable[Any] = UNSET

    href: Optional[str] = None

    products: Optional[Products] = None

    description: Optional[Description] = None

    open_houses: OptionalNullable[Any] = UNSET

    branding: Optional[List[Branding]] = None

    flags: Optional[Flags] = None

    lead_attributes: Optional[LeadAttributes] = None

    virtual_tours: OptionalNullable[Any] = UNSET

    matterport: Optional[bool] = None

    advertisers: Optional[List[Advertisers]] = None

    source: Optional[Source] = None

    pet_policy: Optional[PetPolicy] = None

    property_history: OptionalNullable[Any] = UNSET

    search_promotions: OptionalNullable[Any] = UNSET

    has_specials: Optional[bool] = None

    estimate: OptionalNullable[Any] = UNSET

    current_estimates: Optional[List[Any]] = None

    details: Optional[List[Details]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "__typename",
            "property_id",
            "listing_id",
            "status",
            "primary_photo",
            "photo_count",
            "photos",
            "location",
            "list_price",
            "list_date",
            "list_price_min",
            "list_price_max",
            "price_reduced_date",
            "price_reduced_amount",
            "last_sold_date",
            "last_sold_price",
            "href",
            "products",
            "description",
            "open_houses",
            "branding",
            "flags",
            "lead_attributes",
            "virtual_tours",
            "matterport",
            "advertisers",
            "source",
            "pet_policy",
            "property_history",
            "search_promotions",
            "has_specials",
            "estimate",
            "current_estimates",
            "details",
        ]
        nullable_fields = [
            "list_price",
            "price_reduced_date",
            "price_reduced_amount",
            "last_sold_date",
            "last_sold_price",
            "open_houses",
            "virtual_tours",
            "property_history",
            "search_promotions",
            "estimate",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
