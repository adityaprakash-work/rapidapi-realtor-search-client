"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
import pydantic
from pydantic import model_serializer
from rapidapi_realtor_search_client.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from typing import Any, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class PropertyDetailResponseLoanTypeTypedDict(TypedDict):
    term: NotRequired[int]


class PropertyDetailResponseLoanType(BaseModel):
    term: Optional[int] = None


class AverageRateTypedDict(TypedDict):
    rate: NotRequired[float]
    loan_type: NotRequired[PropertyDetailResponseLoanTypeTypedDict]


class AverageRate(BaseModel):
    rate: Optional[float] = None

    loan_type: Optional[PropertyDetailResponseLoanType] = None


class MonthlyPaymentDetailsTypedDict(TypedDict):
    type: NotRequired[str]
    amount: NotRequired[int]
    display_name: NotRequired[str]


class MonthlyPaymentDetails(BaseModel):
    type: Optional[str] = None

    amount: Optional[int] = None

    display_name: Optional[str] = None


class EstimateTypedDict(TypedDict):
    loan_amount: NotRequired[int]
    monthly_payment: NotRequired[int]
    total_payment: NotRequired[int]
    down_payment: NotRequired[int]
    average_rate: NotRequired[AverageRateTypedDict]
    monthly_payment_details: NotRequired[List[MonthlyPaymentDetailsTypedDict]]


class Estimate(BaseModel):
    loan_amount: Optional[int] = None

    monthly_payment: Optional[int] = None

    total_payment: Optional[int] = None

    down_payment: Optional[int] = None

    average_rate: Optional[AverageRate] = None

    monthly_payment_details: Optional[List[MonthlyPaymentDetails]] = None


class LoanTypeTypedDict(TypedDict):
    loan_id: NotRequired[str]


class LoanType(BaseModel):
    loan_id: Optional[str] = None


class AverageRatesTypedDict(TypedDict):
    loan_type: NotRequired[LoanTypeTypedDict]
    rate: NotRequired[float]


class AverageRates(BaseModel):
    loan_type: Optional[LoanType] = None

    rate: Optional[float] = None


class MortgageTypedDict(TypedDict):
    property_tax_rate: NotRequired[float]
    rates_url: NotRequired[str]
    estimate: NotRequired[EstimateTypedDict]
    average_rates: NotRequired[List[AverageRatesTypedDict]]


class Mortgage(BaseModel):
    property_tax_rate: Optional[float] = None

    rates_url: Optional[str] = None

    estimate: Optional[Estimate] = None

    average_rates: Optional[List[AverageRates]] = None


class HoaTypedDict(TypedDict):
    fee: NotRequired[int]


class Hoa(BaseModel):
    fee: Optional[int] = None


class PropertyDetailResponseDescriptionTypedDict(TypedDict):
    baths_consolidated: NotRequired[str]
    baths: NotRequired[int]
    baths_min: NotRequired[Nullable[Any]]
    baths_max: NotRequired[Nullable[Any]]
    heating: NotRequired[Nullable[Any]]
    cooling: NotRequired[Nullable[Any]]
    beds: NotRequired[int]
    beds_min: NotRequired[Nullable[Any]]
    beds_max: NotRequired[Nullable[Any]]
    garage: NotRequired[Nullable[Any]]
    garage_min: NotRequired[Nullable[Any]]
    garage_max: NotRequired[Nullable[Any]]
    pool: NotRequired[Nullable[Any]]
    sqft: NotRequired[Nullable[Any]]
    sqft_min: NotRequired[Nullable[Any]]
    sqft_max: NotRequired[Nullable[Any]]
    styles: NotRequired[Nullable[Any]]
    lot_sqft: NotRequired[int]
    units: NotRequired[int]
    stories: NotRequired[int]
    type: NotRequired[str]
    text: NotRequired[str]
    year_built: NotRequired[int]
    name: NotRequired[Nullable[Any]]


class PropertyDetailResponseDescription(BaseModel):
    baths_consolidated: Optional[str] = None

    baths: Optional[int] = None

    baths_min: OptionalNullable[Any] = UNSET

    baths_max: OptionalNullable[Any] = UNSET

    heating: OptionalNullable[Any] = UNSET

    cooling: OptionalNullable[Any] = UNSET

    beds: Optional[int] = None

    beds_min: OptionalNullable[Any] = UNSET

    beds_max: OptionalNullable[Any] = UNSET

    garage: OptionalNullable[Any] = UNSET

    garage_min: OptionalNullable[Any] = UNSET

    garage_max: OptionalNullable[Any] = UNSET

    pool: OptionalNullable[Any] = UNSET

    sqft: OptionalNullable[Any] = UNSET

    sqft_min: OptionalNullable[Any] = UNSET

    sqft_max: OptionalNullable[Any] = UNSET

    styles: OptionalNullable[Any] = UNSET

    lot_sqft: Optional[int] = None

    units: Optional[int] = None

    stories: Optional[int] = None

    type: Optional[str] = None

    text: Optional[str] = None

    year_built: Optional[int] = None

    name: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "baths_consolidated",
            "baths",
            "baths_min",
            "baths_max",
            "heating",
            "cooling",
            "beds",
            "beds_min",
            "beds_max",
            "garage",
            "garage_min",
            "garage_max",
            "pool",
            "sqft",
            "sqft_min",
            "sqft_max",
            "styles",
            "lot_sqft",
            "units",
            "stories",
            "type",
            "text",
            "year_built",
            "name",
        ]
        nullable_fields = [
            "baths_min",
            "baths_max",
            "heating",
            "cooling",
            "beds_min",
            "beds_max",
            "garage",
            "garage_min",
            "garage_max",
            "pool",
            "sqft",
            "sqft_min",
            "sqft_max",
            "styles",
            "name",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PropertyDetailResponseDataSchoolsTypedDict(TypedDict):
    pass


class PropertyDetailResponseDataSchools(BaseModel):
    pass


class NearbySchoolsTypedDict(TypedDict):
    schools: NotRequired[List[PropertyDetailResponseDataSchoolsTypedDict]]


class NearbySchools(BaseModel):
    schools: Optional[List[PropertyDetailResponseDataSchools]] = None


class PropertyDetailResponseSchoolsTypedDict(TypedDict):
    pass


class PropertyDetailResponseSchools(BaseModel):
    pass


class SchoolsTypedDict(TypedDict):
    schools: NotRequired[List[PropertyDetailResponseSchoolsTypedDict]]


class Schools(BaseModel):
    schools: Optional[List[PropertyDetailResponseSchools]] = None


class PropertyDetailResponseProductsTypedDict(TypedDict):
    products: NotRequired[List[str]]


class PropertyDetailResponseProducts(BaseModel):
    products: Optional[List[str]] = None


class PropertyDetailResponseOpcityLeadAttributesTypedDict(TypedDict):
    flip_the_market_enabled: NotRequired[bool]
    cashback_enabled: NotRequired[bool]
    phones: NotRequired[Nullable[Any]]


class PropertyDetailResponseOpcityLeadAttributes(BaseModel):
    flip_the_market_enabled: Optional[bool] = None

    cashback_enabled: Optional[bool] = None

    phones: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["flip_the_market_enabled", "cashback_enabled", "phones"]
        nullable_fields = ["phones"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ReadyConnectMortgageTypedDict(TypedDict):
    show_contact_a_lender: NotRequired[bool]
    show_veterans_united: NotRequired[bool]


class ReadyConnectMortgage(BaseModel):
    show_contact_a_lender: Optional[bool] = None

    show_veterans_united: Optional[bool] = None


class PropertyDetailResponseLeadAttributesTypedDict(TypedDict):
    opcity_lead_attributes: NotRequired[
        PropertyDetailResponseOpcityLeadAttributesTypedDict
    ]
    ready_connect_mortgage: NotRequired[ReadyConnectMortgageTypedDict]
    lead_type: NotRequired[str]
    show_lead_form: NotRequired[bool]
    disclaimer_text: NotRequired[Nullable[Any]]
    is_tcpa_message_enabled: NotRequired[Nullable[Any]]
    show_text_leads: NotRequired[bool]
    is_premium_ldp: NotRequired[Nullable[Any]]


class PropertyDetailResponseLeadAttributes(BaseModel):
    opcity_lead_attributes: Optional[PropertyDetailResponseOpcityLeadAttributes] = None

    ready_connect_mortgage: Optional[ReadyConnectMortgage] = None

    lead_type: Optional[str] = None

    show_lead_form: Optional[bool] = None

    disclaimer_text: OptionalNullable[Any] = UNSET

    is_tcpa_message_enabled: OptionalNullable[Any] = UNSET

    show_text_leads: Optional[bool] = None

    is_premium_ldp: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "opcity_lead_attributes",
            "ready_connect_mortgage",
            "lead_type",
            "show_lead_form",
            "disclaimer_text",
            "is_tcpa_message_enabled",
            "show_text_leads",
            "is_premium_ldp",
        ]
        nullable_fields = [
            "disclaimer_text",
            "is_tcpa_message_enabled",
            "is_premium_ldp",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PropertyDetailResponseFlagsTypedDict(TypedDict):
    is_contingent: NotRequired[Nullable[Any]]
    is_new_construction: NotRequired[Nullable[Any]]
    is_pending: NotRequired[Nullable[Any]]
    is_foreclosure: NotRequired[Nullable[Any]]
    is_deal_available: NotRequired[Nullable[Any]]
    is_subdivision: NotRequired[Nullable[Any]]
    is_plan: NotRequired[Nullable[Any]]
    is_price_reduced: NotRequired[Nullable[Any]]
    is_new_listing: NotRequired[bool]
    is_coming_soon: NotRequired[Nullable[Any]]
    is_usda_eligible: NotRequired[bool]


class PropertyDetailResponseFlags(BaseModel):
    is_contingent: OptionalNullable[Any] = UNSET

    is_new_construction: OptionalNullable[Any] = UNSET

    is_pending: OptionalNullable[Any] = UNSET

    is_foreclosure: OptionalNullable[Any] = UNSET

    is_deal_available: OptionalNullable[Any] = UNSET

    is_subdivision: OptionalNullable[Any] = UNSET

    is_plan: OptionalNullable[Any] = UNSET

    is_price_reduced: OptionalNullable[Any] = UNSET

    is_new_listing: Optional[bool] = None

    is_coming_soon: OptionalNullable[Any] = UNSET

    is_usda_eligible: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "is_contingent",
            "is_new_construction",
            "is_pending",
            "is_foreclosure",
            "is_deal_available",
            "is_subdivision",
            "is_plan",
            "is_price_reduced",
            "is_new_listing",
            "is_coming_soon",
            "is_usda_eligible",
        ]
        nullable_fields = [
            "is_contingent",
            "is_new_construction",
            "is_pending",
            "is_foreclosure",
            "is_deal_available",
            "is_subdivision",
            "is_plan",
            "is_price_reduced",
            "is_coming_soon",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DisclaimerTypedDict(TypedDict):
    text: NotRequired[str]
    href: NotRequired[Nullable[Any]]


class Disclaimer(BaseModel):
    text: Optional[str] = None

    href: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["text", "href"]
        nullable_fields = ["href"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class AgentsTypedDict(TypedDict):
    agent_name: NotRequired[str]


class Agents(BaseModel):
    agent_name: Optional[str] = None


class PropertyDetailResponseSourceTypedDict(TypedDict):
    id: NotRequired[str]
    disclaimer: NotRequired[DisclaimerTypedDict]
    listing_id: NotRequired[str]
    plan_id: NotRequired[Nullable[Any]]
    spec_id: NotRequired[Nullable[Any]]
    community_id: NotRequired[Nullable[Any]]
    name: NotRequired[str]
    type: NotRequired[str]
    feed_type: NotRequired[Nullable[Any]]
    agents: NotRequired[List[AgentsTypedDict]]


class PropertyDetailResponseSource(BaseModel):
    id: Optional[str] = None

    disclaimer: Optional[Disclaimer] = None

    listing_id: Optional[str] = None

    plan_id: OptionalNullable[Any] = UNSET

    spec_id: OptionalNullable[Any] = UNSET

    community_id: OptionalNullable[Any] = UNSET

    name: Optional[str] = None

    type: Optional[str] = None

    feed_type: OptionalNullable[Any] = UNSET

    agents: Optional[List[Agents]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "id",
            "disclaimer",
            "listing_id",
            "plan_id",
            "spec_id",
            "community_id",
            "name",
            "type",
            "feed_type",
            "agents",
        ]
        nullable_fields = ["plan_id", "spec_id", "community_id", "feed_type"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PropertyDetailResponseDetailsTypedDict(TypedDict):
    category: NotRequired[str]
    text: NotRequired[List[str]]


class PropertyDetailResponseDetails(BaseModel):
    category: Optional[str] = None

    text: Optional[List[str]] = None


class AssessmentTypedDict(TypedDict):
    building: NotRequired[int]
    land: NotRequired[int]
    total: NotRequired[int]


class Assessment(BaseModel):
    building: Optional[int] = None

    land: Optional[int] = None

    total: Optional[int] = None


class TaxHistoryTypedDict(TypedDict):
    tax: NotRequired[int]
    year: NotRequired[int]
    assessment: NotRequired[AssessmentTypedDict]


class TaxHistory(BaseModel):
    tax: Optional[int] = None

    year: Optional[int] = None

    assessment: Optional[Assessment] = None


class PropertyDetailResponseCoordinateTypedDict(TypedDict):
    lat: NotRequired[float]
    lon: NotRequired[float]


class PropertyDetailResponseCoordinate(BaseModel):
    lat: Optional[float] = None

    lon: Optional[float] = None


class PropertyDetailResponseAddressTypedDict(TypedDict):
    line: NotRequired[str]
    city: NotRequired[str]
    state_code: NotRequired[str]
    postal_code: NotRequired[str]
    state: NotRequired[str]
    coordinate: NotRequired[PropertyDetailResponseCoordinateTypedDict]


class PropertyDetailResponseAddress(BaseModel):
    line: Optional[str] = None

    city: Optional[str] = None

    state_code: Optional[str] = None

    postal_code: Optional[str] = None

    state: Optional[str] = None

    coordinate: Optional[PropertyDetailResponseCoordinate] = None


class PropertyDetailResponseCountyTypedDict(TypedDict):
    fips_code: NotRequired[str]


class PropertyDetailResponseCounty(BaseModel):
    fips_code: Optional[str] = None


class HousingMarketTypedDict(TypedDict):
    median_price_per_sqft: NotRequired[int]
    median_sold_price: NotRequired[int]
    median_listing_price: NotRequired[int]
    median_days_on_market: NotRequired[int]


class HousingMarket(BaseModel):
    median_price_per_sqft: Optional[int] = None

    median_sold_price: Optional[int] = None

    median_listing_price: Optional[int] = None

    median_days_on_market: Optional[int] = None


class GeoStatisticsTypedDict(TypedDict):
    housing_market: NotRequired[HousingMarketTypedDict]


class GeoStatistics(BaseModel):
    housing_market: Optional[HousingMarket] = None


class PropertyDetailResponseNeighborhoodsTypedDict(TypedDict):
    name: NotRequired[str]
    geo_statistics: NotRequired[GeoStatisticsTypedDict]


class PropertyDetailResponseNeighborhoods(BaseModel):
    name: Optional[str] = None

    geo_statistics: Optional[GeoStatistics] = None


class PropertyDetailResponseLocationTypedDict(TypedDict):
    address: NotRequired[PropertyDetailResponseAddressTypedDict]
    county: NotRequired[PropertyDetailResponseCountyTypedDict]
    street_view_url: NotRequired[str]
    neighborhoods: NotRequired[List[PropertyDetailResponseNeighborhoodsTypedDict]]


class PropertyDetailResponseLocation(BaseModel):
    address: Optional[PropertyDetailResponseAddress] = None

    county: Optional[PropertyDetailResponseCounty] = None

    street_view_url: Optional[str] = None

    neighborhoods: Optional[List[PropertyDetailResponseNeighborhoods]] = None


class PropertyDetailResponseBrandingTypedDict(TypedDict):
    type: NotRequired[str]
    photo: NotRequired[Nullable[Any]]
    name: NotRequired[str]
    phone: NotRequired[Nullable[Any]]
    slogan: NotRequired[Nullable[Any]]
    accent_color: NotRequired[Nullable[Any]]


class PropertyDetailResponseBranding(BaseModel):
    type: Optional[str] = None

    photo: OptionalNullable[Any] = UNSET

    name: Optional[str] = None

    phone: OptionalNullable[Any] = UNSET

    slogan: OptionalNullable[Any] = UNSET

    accent_color: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["type", "photo", "name", "phone", "slogan", "accent_color"]
        nullable_fields = ["photo", "phone", "slogan", "accent_color"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ConsumerAdvertisersTypedDict(TypedDict):
    pass


class ConsumerAdvertisers(BaseModel):
    pass


class PhonesTypedDict(TypedDict):
    number: NotRequired[str]
    type: NotRequired[str]
    ext: NotRequired[Nullable[Any]]
    trackable: NotRequired[Nullable[Any]]
    primary: NotRequired[bool]


class Phones(BaseModel):
    number: Optional[str] = None

    type: Optional[str] = None

    ext: OptionalNullable[Any] = UNSET

    trackable: OptionalNullable[Any] = UNSET

    primary: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["number", "type", "ext", "trackable", "primary"]
        nullable_fields = ["ext", "trackable"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PhotoTypedDict(TypedDict):
    href: NotRequired[str]


class Photo(BaseModel):
    href: Optional[str] = None


class PropertyDetailResponsePhonesTypedDict(TypedDict):
    number: NotRequired[str]
    type: NotRequired[str]
    ext: NotRequired[str]
    trackable: NotRequired[Nullable[Any]]
    primary: NotRequired[bool]


class PropertyDetailResponsePhones(BaseModel):
    number: Optional[str] = None

    type: Optional[str] = None

    ext: Optional[str] = None

    trackable: OptionalNullable[Any] = UNSET

    primary: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["number", "type", "ext", "trackable", "primary"]
        nullable_fields = ["trackable"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PropertyDetailResponseDataAddressTypedDict(TypedDict):
    city: NotRequired[str]
    state_code: NotRequired[str]


class PropertyDetailResponseDataAddress(BaseModel):
    city: Optional[str] = None

    state_code: Optional[str] = None


class PropertyDetailResponseOfficeTypedDict(TypedDict):
    fulfillment_id: NotRequired[str]
    name: NotRequired[str]
    href: NotRequired[Nullable[Any]]
    photo: NotRequired[PhotoTypedDict]
    email: NotRequired[str]
    phones: NotRequired[List[PropertyDetailResponsePhonesTypedDict]]
    address: NotRequired[PropertyDetailResponseDataAddressTypedDict]


class PropertyDetailResponseOffice(BaseModel):
    fulfillment_id: Optional[str] = None

    name: Optional[str] = None

    href: OptionalNullable[Any] = UNSET

    photo: Optional[Photo] = None

    email: Optional[str] = None

    phones: Optional[List[PropertyDetailResponsePhones]] = None

    address: Optional[PropertyDetailResponseDataAddress] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "fulfillment_id",
            "name",
            "href",
            "photo",
            "email",
            "phones",
            "address",
        ]
        nullable_fields = ["href"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PropertyDetailResponseAdvertisersTypedDict(TypedDict):
    fulfillment_id: NotRequired[str]
    name: NotRequired[str]
    type: NotRequired[str]
    email: NotRequired[str]
    href: NotRequired[Nullable[Any]]
    state_license: NotRequired[str]
    phones: NotRequired[List[PhonesTypedDict]]
    builder: NotRequired[Nullable[Any]]
    office: NotRequired[PropertyDetailResponseOfficeTypedDict]
    broker: NotRequired[Nullable[Any]]
    photo: NotRequired[Nullable[Any]]
    rental_management: NotRequired[Nullable[Any]]


class PropertyDetailResponseAdvertisers(BaseModel):
    fulfillment_id: Optional[str] = None

    name: Optional[str] = None

    type: Optional[str] = None

    email: Optional[str] = None

    href: OptionalNullable[Any] = UNSET

    state_license: Optional[str] = None

    phones: Optional[List[Phones]] = None

    builder: OptionalNullable[Any] = UNSET

    office: Optional[PropertyDetailResponseOffice] = None

    broker: OptionalNullable[Any] = UNSET

    photo: OptionalNullable[Any] = UNSET

    rental_management: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "fulfillment_id",
            "name",
            "type",
            "email",
            "href",
            "state_license",
            "phones",
            "builder",
            "office",
            "broker",
            "photo",
            "rental_management",
        ]
        nullable_fields = ["href", "builder", "broker", "photo", "rental_management"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TagsTypedDict(TypedDict):
    label: NotRequired[str]
    probability: NotRequired[float]


class Tags(BaseModel):
    label: Optional[str] = None

    probability: Optional[float] = None


class PropertyDetailResponsePhotosTypedDict(TypedDict):
    href: NotRequired[str]
    type: NotRequired[str]
    tags: NotRequired[List[TagsTypedDict]]


class PropertyDetailResponsePhotos(BaseModel):
    href: Optional[str] = None

    type: Optional[str] = None

    tags: Optional[List[Tags]] = None


class PropertyHistoryTypedDict(TypedDict):
    pass


class PropertyHistory(BaseModel):
    pass


class NoiseCategoriesTypedDict(TypedDict):
    type: NotRequired[str]
    text: NotRequired[str]


class NoiseCategories(BaseModel):
    type: Optional[str] = None

    text: Optional[str] = None


class NoiseTypedDict(TypedDict):
    score: NotRequired[int]
    noise_categories: NotRequired[List[NoiseCategoriesTypedDict]]


class Noise(BaseModel):
    score: Optional[int] = None

    noise_categories: Optional[List[NoiseCategories]] = None


class InsuranceRatesTypedDict(TypedDict):
    provider_url: NotRequired[str]


class InsuranceRates(BaseModel):
    provider_url: Optional[str] = None


class FloodTypedDict(TypedDict):
    fsid: NotRequired[str]
    flood_factor_score: NotRequired[int]
    flood_trend_paragraph: NotRequired[str]
    firststreet_url: NotRequired[str]
    fema_zone: NotRequired[List[str]]
    flood_insurance_text: NotRequired[str]
    insurance_rates: NotRequired[List[InsuranceRatesTypedDict]]


class Flood(BaseModel):
    fsid: Optional[str] = None

    flood_factor_score: Optional[int] = None

    flood_trend_paragraph: Optional[str] = None

    firststreet_url: Optional[str] = None

    fema_zone: Optional[List[str]] = None

    flood_insurance_text: Optional[str] = None

    insurance_rates: Optional[List[InsuranceRates]] = None


class LocalTypedDict(TypedDict):
    noise: NotRequired[NoiseTypedDict]
    flood: NotRequired[FloodTypedDict]


class Local(BaseModel):
    noise: Optional[Noise] = None

    flood: Optional[Flood] = None


class PropertyDetailResponseDataSourceTypedDict(TypedDict):
    type: NotRequired[str]
    name: NotRequired[str]


class PropertyDetailResponseDataSource(BaseModel):
    type: Optional[str] = None

    name: Optional[str] = None


class CurrentValuesTypedDict(TypedDict):
    source: NotRequired[PropertyDetailResponseDataSourceTypedDict]
    estimate: NotRequired[int]
    isbest_homevalue: NotRequired[bool]


class CurrentValues(BaseModel):
    source: Optional[PropertyDetailResponseDataSource] = None

    estimate: Optional[int] = None

    isbest_homevalue: Optional[bool] = None


class PropertyDetailResponseDataEstimatesSourceTypedDict(TypedDict):
    type: NotRequired[str]
    name: NotRequired[str]


class PropertyDetailResponseDataEstimatesSource(BaseModel):
    type: Optional[str] = None

    name: Optional[str] = None


class PropertyDetailResponseDataEstimatesTypedDict(TypedDict):
    estimate: NotRequired[int]
    date_: NotRequired[str]


class PropertyDetailResponseDataEstimates(BaseModel):
    estimate: Optional[int] = None

    date_: Annotated[Optional[str], pydantic.Field(alias="date")] = None


class HistoricalValuesTypedDict(TypedDict):
    source: NotRequired[PropertyDetailResponseDataEstimatesSourceTypedDict]
    estimates: NotRequired[List[PropertyDetailResponseDataEstimatesTypedDict]]


class HistoricalValues(BaseModel):
    source: Optional[PropertyDetailResponseDataEstimatesSource] = None

    estimates: Optional[List[PropertyDetailResponseDataEstimates]] = None


class PropertyDetailResponseDataEstimatesForecastValuesSourceTypedDict(TypedDict):
    type: NotRequired[str]
    name: NotRequired[str]


class PropertyDetailResponseDataEstimatesForecastValuesSource(BaseModel):
    type: Optional[str] = None

    name: Optional[str] = None


class PropertyDetailResponseEstimatesTypedDict(TypedDict):
    estimate: NotRequired[int]
    date_: NotRequired[str]


class PropertyDetailResponseEstimates(BaseModel):
    estimate: Optional[int] = None

    date_: Annotated[Optional[str], pydantic.Field(alias="date")] = None


class ForecastValuesTypedDict(TypedDict):
    source: NotRequired[
        PropertyDetailResponseDataEstimatesForecastValuesSourceTypedDict
    ]
    estimates: NotRequired[List[PropertyDetailResponseEstimatesTypedDict]]


class ForecastValues(BaseModel):
    source: Optional[PropertyDetailResponseDataEstimatesForecastValuesSource] = None

    estimates: Optional[List[PropertyDetailResponseEstimates]] = None


class EstimatesTypedDict(TypedDict):
    current_values: NotRequired[List[CurrentValuesTypedDict]]
    historical_values: NotRequired[List[HistoricalValuesTypedDict]]
    forecast_values: NotRequired[List[ForecastValuesTypedDict]]


class Estimates(BaseModel):
    current_values: Optional[List[CurrentValues]] = None

    historical_values: Optional[List[HistoricalValues]] = None

    forecast_values: Optional[List[ForecastValues]] = None


class HomeToursTypedDict(TypedDict):
    virtual_tours: NotRequired[List[Any]]


class HomeTours(BaseModel):
    virtual_tours: Optional[List[Any]] = None


class PropertyDetailResponseDataTypedDict(TypedDict):
    property_id: NotRequired[str]
    last_update_date: NotRequired[str]
    last_price_change_date: NotRequired[Nullable[Any]]
    last_price_change_amount: NotRequired[Nullable[Any]]
    listing_id: NotRequired[str]
    status: NotRequired[str]
    href: NotRequired[str]
    list_date: NotRequired[str]
    mortgage: NotRequired[MortgageTypedDict]
    hoa: NotRequired[HoaTypedDict]
    buyers: NotRequired[Nullable[Any]]
    description: NotRequired[PropertyDetailResponseDescriptionTypedDict]
    pet_policy: NotRequired[Nullable[Any]]
    nearby_schools: NotRequired[NearbySchoolsTypedDict]
    schools: NotRequired[SchoolsTypedDict]
    products: NotRequired[PropertyDetailResponseProductsTypedDict]
    list_price: NotRequired[int]
    list_price_min: NotRequired[Nullable[Any]]
    list_price_max: NotRequired[Nullable[Any]]
    price_per_sqft: NotRequired[Nullable[Any]]
    community: NotRequired[Nullable[Any]]
    lead_attributes: NotRequired[PropertyDetailResponseLeadAttributesTypedDict]
    flags: NotRequired[PropertyDetailResponseFlagsTypedDict]
    provider_url: NotRequired[Nullable[Any]]
    source: NotRequired[PropertyDetailResponseSourceTypedDict]
    details: NotRequired[List[PropertyDetailResponseDetailsTypedDict]]
    open_houses: NotRequired[Nullable[Any]]
    tax_history: NotRequired[List[TaxHistoryTypedDict]]
    location: NotRequired[PropertyDetailResponseLocationTypedDict]
    branding: NotRequired[List[PropertyDetailResponseBrandingTypedDict]]
    consumer_advertisers: NotRequired[List[ConsumerAdvertisersTypedDict]]
    specials: NotRequired[Nullable[Any]]
    advertisers: NotRequired[List[PropertyDetailResponseAdvertisersTypedDict]]
    photo_count: NotRequired[int]
    photos: NotRequired[List[PropertyDetailResponsePhotosTypedDict]]
    property_history: NotRequired[List[PropertyHistoryTypedDict]]
    local: NotRequired[LocalTypedDict]
    last_sold_price: NotRequired[int]
    last_sold_date: NotRequired[str]
    estimates: NotRequired[EstimatesTypedDict]
    virtual_tours: NotRequired[Nullable[Any]]
    home_tours: NotRequired[HomeToursTypedDict]
    matterport: NotRequired[Nullable[Any]]
    terms: NotRequired[Nullable[Any]]
    monthly_fees: NotRequired[Nullable[Any]]
    one_time_fees: NotRequired[Nullable[Any]]
    units: NotRequired[Nullable[Any]]
    community_rental_floorplans: NotRequired[Nullable[Any]]


class PropertyDetailResponseData(BaseModel):
    property_id: Optional[str] = None

    last_update_date: Optional[str] = None

    last_price_change_date: OptionalNullable[Any] = UNSET

    last_price_change_amount: OptionalNullable[Any] = UNSET

    listing_id: Optional[str] = None

    status: Optional[str] = None

    href: Optional[str] = None

    list_date: Optional[str] = None

    mortgage: Optional[Mortgage] = None

    hoa: Optional[Hoa] = None

    buyers: OptionalNullable[Any] = UNSET

    description: Optional[PropertyDetailResponseDescription] = None

    pet_policy: OptionalNullable[Any] = UNSET

    nearby_schools: Optional[NearbySchools] = None

    schools: Optional[Schools] = None

    products: Optional[PropertyDetailResponseProducts] = None

    list_price: Optional[int] = None

    list_price_min: OptionalNullable[Any] = UNSET

    list_price_max: OptionalNullable[Any] = UNSET

    price_per_sqft: OptionalNullable[Any] = UNSET

    community: OptionalNullable[Any] = UNSET

    lead_attributes: Optional[PropertyDetailResponseLeadAttributes] = None

    flags: Optional[PropertyDetailResponseFlags] = None

    provider_url: OptionalNullable[Any] = UNSET

    source: Optional[PropertyDetailResponseSource] = None

    details: Optional[List[PropertyDetailResponseDetails]] = None

    open_houses: OptionalNullable[Any] = UNSET

    tax_history: Optional[List[TaxHistory]] = None

    location: Optional[PropertyDetailResponseLocation] = None

    branding: Optional[List[PropertyDetailResponseBranding]] = None

    consumer_advertisers: Optional[List[ConsumerAdvertisers]] = None

    specials: OptionalNullable[Any] = UNSET

    advertisers: Optional[List[PropertyDetailResponseAdvertisers]] = None

    photo_count: Optional[int] = None

    photos: Optional[List[PropertyDetailResponsePhotos]] = None

    property_history: Optional[List[PropertyHistory]] = None

    local: Optional[Local] = None

    last_sold_price: Optional[int] = None

    last_sold_date: Optional[str] = None

    estimates: Optional[Estimates] = None

    virtual_tours: OptionalNullable[Any] = UNSET

    home_tours: Optional[HomeTours] = None

    matterport: OptionalNullable[Any] = UNSET

    terms: OptionalNullable[Any] = UNSET

    monthly_fees: OptionalNullable[Any] = UNSET

    one_time_fees: OptionalNullable[Any] = UNSET

    units: OptionalNullable[Any] = UNSET

    community_rental_floorplans: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "property_id",
            "last_update_date",
            "last_price_change_date",
            "last_price_change_amount",
            "listing_id",
            "status",
            "href",
            "list_date",
            "mortgage",
            "hoa",
            "buyers",
            "description",
            "pet_policy",
            "nearby_schools",
            "schools",
            "products",
            "list_price",
            "list_price_min",
            "list_price_max",
            "price_per_sqft",
            "community",
            "lead_attributes",
            "flags",
            "provider_url",
            "source",
            "details",
            "open_houses",
            "tax_history",
            "location",
            "branding",
            "consumer_advertisers",
            "specials",
            "advertisers",
            "photo_count",
            "photos",
            "property_history",
            "local",
            "last_sold_price",
            "last_sold_date",
            "estimates",
            "virtual_tours",
            "home_tours",
            "matterport",
            "terms",
            "monthly_fees",
            "one_time_fees",
            "units",
            "community_rental_floorplans",
        ]
        nullable_fields = [
            "last_price_change_date",
            "last_price_change_amount",
            "buyers",
            "pet_policy",
            "list_price_min",
            "list_price_max",
            "price_per_sqft",
            "community",
            "provider_url",
            "open_houses",
            "specials",
            "virtual_tours",
            "matterport",
            "terms",
            "monthly_fees",
            "one_time_fees",
            "units",
            "community_rental_floorplans",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PropertyDetailResponseTypedDict(TypedDict):
    data: NotRequired[PropertyDetailResponseDataTypedDict]
    status: NotRequired[bool]
    message: NotRequired[str]


class PropertyDetailResponse(BaseModel):
    data: Optional[PropertyDetailResponseData] = None

    status: Optional[bool] = None

    message: Optional[str] = None
